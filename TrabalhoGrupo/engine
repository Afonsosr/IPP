# -*- coding:utf-8 -*-
'''
Adapted on 01/03/2023

@author: valves
@author: ferraz
'''

class ProteinasEngine:
    
    def __init__(self, seq=""):
        self.sequencia = seq
        self.coordenadas = []
        pass
    
	
    def getseq(self):
        return self.sequencia  
    
	
    def setseq(self, seq):
        self.sequencia = seq
        
    def verificar_parenteses(self,frase):
                pilha = []
                a = 0
                b = 0
                for caractere in frase:
                    if caractere == '('or caractere == ')':
                        pilha.append(caractere)
                        if caractere == '(':                    # funcao que verifica os parentises de uma sequencia
                            a += 1                                   
                        else:
                            b += 1
                if len(pilha)==0:
                    return True                                
                elif pilha[-1]==')' and a == b:            
                    return True
                else:
                    return False	

    def seq_valida(self, seq_a_verificar):
        car_validos = "AB()1234567890"    # verifica estes todos para o caso de receber uma sequencia compactada
        num = "1234567890"
        if ProteinasEngine.verificar_parenteses(self,seq_a_verificar) == False:
            return False
        if str(list(seq_a_verificar)[0]) in num:
            return False
        for car in seq_a_verificar:
            if car not in car_validos:            
                return False
        for i in range(0,len(list(seq_a_verificar))-1):
            if list(seq_a_verificar)[i] == "(" and list(seq_a_verificar)[i+1] == ")":  #verifica se ha parenteses sem conteudo
                return False
            elif list(seq_a_verificar)[i] == ")" and list(seq_a_verificar)[i+1] not in num:
                return False                                                                   #verifica se ha parenteses sem numero a seguir
        return True


    def convert_coords_to_list_of_list(self, coords):  # converte string de coordenadas em lista de lista de coordenadas
        coords = coords.replace(")(", ");(")
        L = coords.split(";")
        Lista_coords = []
        for c in L:
            li = c.strip("()").split(",")
            cc = []
            for t in li:  # para converter todos os valores para números inteiros
                cc.append(int(t))
            Lista_coords.append(cc)
        return Lista_coords


    def convert_list_of_list_to_coords(self, lista_coords):  # converte  lista de lista de coordenadas em string
        coords = ""
        for c in lista_coords:
            coords = coords + "(%d,%d)" % (c[0], c[1])
        return coords


    def getcoord(self):  # ter em atenção que as coordenadas são guardadas numa lista de listas
        return self.convert_list_of_list_to_coords(self.coordenadas)  
    
	
    def setcoord(self, coord):
        self.coordenadas = self.convert_coords_to_list_of_list(coord)
        
		
    def coord_validas(self,coord_a_verificar): 
        
        car_validos = " ()0123456789,-[]"
        for car in coord_a_verificar:
            if car not in car_validos:
                return False
        return True

    def coords_totais_seguidas(self,coordsTodas):
        f = 0
        for i in range(0,len(coordsTodas)-1):
            a = [coordsTodas[i][0],coordsTodas[i][1]+1]
            b = [coordsTodas[i][0],coordsTodas[i][1]-1]
            c = [coordsTodas[i][0]+1,coordsTodas[i][1]]
            d = [coordsTodas[i][0]-1,coordsTodas[i][1]]
            lisaux=[a,b,c,d]            
            if coordsTodas[i+1] in lisaux:
                f += 1
        if f != 0:
            return True
        else:
            return False        

    def max_coord_x(self):  # determina qual o valor maximo de x em todas as coordenadas
        maximo = 0  # pois a primeira coordenada está sempre na posição (0,0)
        for c in self.coordenadas: 
            if c[0] > maximo:
                maximo = c[0]
        return maximo

    def min_coord_x(self):  # determina qual o valor maximo de x em todas as coordenadas
        minimo = 0  # pois a primeira coordenada está sempre na posição (0,0)
        for c in self.coordenadas: 
            if c[0] < minimo:
                minimo = c[0]
        return minimo

    def max_coord_y(self):  # determina qual o valor maximo de x em todas as coordenadas
        maximo = 0  # pois a primeira coordenada está sempre na posição (0,0)
        for c in self.coordenadas: 
            if c[1] > maximo:
                maximo = c[1]
        return maximo


    def min_coord_y(self):  # determina qual o valor máximo de x em todas as coordenadas
        minimo = 0  # pois a primeira coordenada está sempre na posição (0,0)
        for c in self.coordenadas: 
            if c[1] < minimo:
                minimo = c[1]
        return minimo
    
	
    def get_matriz_total(self):
        '''
        retorna uma matriz em que cada linha tem o caratere seguido das coordenadas:
        [["B",0,0],["A",1,0]...]
        '''
        Matriz = []
        for i in range(len(self.sequencia)):
            lin = []
            lin.append(self.sequencia[i])
            lin.append(self.coordenadas[i][0])
            lin.append(self.coordenadas[i][1])
            Matriz.append(lin)
        return Matriz            




    def validacao(self,seq,coords):
        
        if ProteinasEngine.seq_valida(self,seq) and ProteinasEngine.verificar_parenteses(self,seq):
            for coord in coords:
                if ProteinasEngine.coord_validas(self,str(coord)) and ProteinasEngine.coords_totais_seguidas(self,coords):
                    return True
        return False
    

