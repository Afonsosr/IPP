# -*- coding:utf-8 -*-
'''
Adapted on 01/03/2023

@author: valves
@author: ferraz
'''

from cmd import Cmd
from ProteinasWindow import ProteinasWindow
from ProteinasEngine import ProteinasEngine
import random
import re
from itertools import combinations_with_replacement
import fontstyle

class ProteinasShell(Cmd):
    intro = 'Interpretador de comandos para jogo das proteínas. Escrever help ou ? para listar os comandos disponíveis.\n'
    prompt = 'Proteínas> '

    def descompactar(arg):
            nums=["0","1","2","3","4","5","6","7","8","9"]
            arg = arg.upper()
            lista_arg = list(arg)
            num_args = len(lista_arg)        
            i = 0
            s = ""
            urep = ""
            #for elem in lis
            while i < num_args -1  :
                if arg[i+1] in nums and arg[i] != ")":     # funcao para descompactar sequencia descompactada
                    s = s + arg[i]*int(arg[i+1])
                    
                    i += 2
                elif arg[i] == "(":
                    while arg[i] != ")":
                        i += 1
                        urep = urep + arg[i]
                        urep = urep.replace(")","")
                    s = s +  urep*int(arg[i+1])

                    urep = ""
                    i += 2
                else:
                    s = s + arg[i]
                    i += 1
            if lista_arg[-1] not in nums:
                s += lista_arg[-1]
            return s



        

    def do_seq(self, arg):
        " - Sem argumentos imprime a sequência, se tiver um argumento define a sequência constituída por A's e B's: SEQ sequência \n"
        try:
            nums=["0","1","2","3","4","5","6","7","8","9"]
            ax = 0
            lista_arg = arg.split()
            num_args = len(lista_arg)
            if num_args == 0:
                print("SEQ: ", eng.sequencia)
            elif num_args == 1:
                for elem in nums:
                    if elem in arg:
                        ax += 1
                if ax != 0:
                    eng.setseq(ProteinasShell.descompactar(arg))               # descompactar sequencia compactada
                    print("A sequência foi atualizada")
                    print("SEQ: ", eng.sequencia)
                else:
                    seq = lista_arg[0].upper()  # assim forço a que a string esteja em maiúsculas
                    if eng.seq_valida(seq):  # para verificar se a sequência é válida
                        eng.setseq(seq)
                        print("A sequência foi atualizada")
                        print()
                    else:
                        print("A sequência tem carateres inválidos. Por favor, reinsira uma sequência válida.")
            else:
                print("Número de argumentos inválido!")
        except BaseException as e:
            print("Erro: ao executar o comando SEQ:" , str(e))



        
    def do_dobrar(self, arg):
        " - Comando que recebe como argumento uma string com instruções (FED) que serão utilizadas para dobrar a sequência: DOBRAR instruções \n"
        try:
            arg = arg.upper()
            lista_arg = list(arg)
            n = len(lista_arg)
            #print(lista_arg) #isto depois é pra apagar
            #print(eng.coordenadas) # isto depois é para apagar
            
            if len(lista_arg) > len(eng.sequencia)-1:
                print("Número de argumentos inválido! Tem de ser <= a: ",len(eng.sequencia)-1) 

            else:
                if len(lista_arg) == len(eng.sequencia)-1:
                    pass
                elif len(lista_arg) < len(eng.sequencia)-1:         # AQUI ASSUMIMOS AS DOBRAR COMO F CASO O ARGUMENTO SEJA MENOR QUE O SUPOSTO
                    while len(lista_arg) < len(eng.sequencia)-1:    
                        lista_arg.append("F")

                auxiliar_de_direcao = "frente"
                k = 0
                while k <= n-1:    
                    for elem in lista_arg:
                        if auxiliar_de_direcao == "frente" :                                              
                            if elem == "F":      
                                eng.coordenadas[k+1][0] += 1
                                auxiliar_de_direcao = "frente"
                            elif elem == "E":
                                eng.coordenadas[k+1][1] -= 1
                                auxiliar_de_direcao = "esquerda"
                            elif elem == "D":        
                                eng.coordenadas[k+1][1] += 1
                                auxiliar_de_direcao = "direita"
                       
                        elif auxiliar_de_direcao == "esquerda" : 
                            if elem == "F":                                             
                                eng.coordenadas[k+1][1] -= 1
                                auxiliar_de_direcao = "esquerda"
                            elif elem == "E":      
                                eng.coordenadas[k+1][0] -= 1
                                auxiliar_de_direcao = "tras"
                            elif elem == "D":                     
                                eng.coordenadas[k+1][0] += 1
                                auxiliar_de_direcao = "frente"
                       
                        elif auxiliar_de_direcao == "direita" :
                            if elem == "F":                                                                    
                                eng.coordenadas[k+1][1] += 1
                                auxiliar_de_direcao = "direita" 
                            elif elem == "E":                 
                                eng.coordenadas[k+1][0] += 1
                                auxiliar_de_direcao = "frente"
                            elif elem == "D":                                 
                                eng.coordenadas[k+1][0] -= 1
                                auxiliar_de_direcao = "tras"

                        elif auxiliar_de_direcao == "tras" :
                            if elem == "F":                                                                   
                                eng.coordenadas[k+1][0] -= 1
                                auxiliar_de_direcao = "tras"
                            elif elem == "E":                           
                                eng.coordenadas[k+1][1] += 1
                                auxiliar_de_direcao = "direita"
                            elif elem == "D":                                     
                                eng.coordenadas[k+1][1] -= 1
                                auxiliar_de_direcao = "esquerda"
                    k += 1
                print("As coordenadas foram atualizadas")
                #return eng.coordenadas
        except BaseException as e:
            print("Erro: ao fazer o DOBRAR:" , str(e))    
                
	
    def do_coords(self, arg):    
        " - Sem argumentos imprime as coordenadas de cada caratere da sequência, se tiver um argumento define a posição (X,Y) de cada caratere da sequência: COORDS posições \n"
        try:    
            lista_arg = arg.split()
            num_args = len(lista_arg)
            if num_args == 0:  # imprimir a lista de coordenadas
                coordenadas = eng.getcoord()
                print("COORDENADAS: ", coordenadas)
            elif num_args == 1:
                coordenadas = lista_arg[0]
                if eng.coord_validas(coordenadas):  # para verificar se a string de coordenadas é válida
                    eng.setcoord(coordenadas)
                    print("As coordenadas foram atualizadas")
                else:
                    print("A string de coordenadas tem carateres inválidos, o formato é (x,y)...")
            else:
                print("Número de argumentos inválido!")
        except BaseException as e:
            print("Erro: ao fazer o COORDS:", str(e))
#################################################################################################           

    def do_validar(self, arg):    
            " - Comando que valida a configuração atual da proteína; este comando deverá imprimir as palavras SIM ou NAO caso a configuração seja válida: VALIDAR \n"
            try:
                lista_arg = arg.split()
                num_args = len(lista_arg)
                if num_args == 0:
                    if eng.validacao(eng.sequencia,eng.coordenadas):
                        print(fontstyle.apply('SIM', 'Italic'))
                    else:
                        print(fontstyle.apply('NAO', 'Italic'))
                else:
                    print("O comando validar nao leva argumentos!")
            except BaseException as e:
                print("Erro ao fazer o validar!", str(e))

#################################################################################################   


    def do_compactar(self, arg): 
        try:
            lista_arg = list(arg)
            num_args = len(lista_arg)
            if num_args == 0:
                print("Número de argumentos inválido!")
            else:
                def repl(m):
                    opening = m.group(1)
                    first = m.group(2)
                    repetitions = m.group(3)
                    closing = m.group(4)
                    wrapper_repeat = m.group(5)
                    repeats = 1 + len(repetitions) // len(first)
                    if len(first) > 1:
                        first = '(' + first + ')'                   # encontrado na internet
                    if opening and wrapper_repeat:
                        # simplify
                        repeats = repeats * int(wrapper_repeat)
                        return first + str(repeats)
                    return opening + first + str(repeats) + closing + wrapper_repeat

                seq2 = '';
                while seq2 != arg:
                    seq2 = arg
                    arg = re.sub(r'(\(?)([^\d()]+)(\2+)(\)?)(\d*)', repl, seq2)
            return print(arg)
        except BaseException as e:
            print("Erro: ao fazer o COMPACTAR:", str(e))

	
    def do_gravar(self, arg):    
        " - Comando invocado com um argumento que será o nome de um ficheiro onde a aplicação deverá armazenar a sequência e as coordenadas: GRAVAR nomef.txt \n"
        try:
            fp = open(arg, "w")
            for e in range(0,len(eng.coordenadas)):
                fp.write(str(eng.sequencia[e]) + " -> " + str(eng.coordenadas[e]) + ";")
                fp.write("\n")
            fp.close()
            print ("Ficheiro atualizado com sucesso!")
        except BaseException as e:
            print("Erro: ao fazer o GRAVAR:", str(e))
    
	
    def do_ler(self, arg):    
        " - Comando invocado com um argumento que será o nome de um ficheiro de onde a aplicação deverá ler a sequência e as coordenadas: LER nomef.txt \n"
        try:
            fp = open(arg, "r")
            for e in range(0,len(eng.coordenadas)):
                print("")
                print(str(eng.sequencia[e]) + " -> " + str(eng.coordenadas[e]) + ";")
                print("")
            fp.close()
        except BaseException as e:
            print("Erro: ao fazer o LER:", str(e))		
		
    def do_energia(self, arg):    
        " - Comando que imprime a energia da configuração atual caso esta seja válida; este comando pode ser invocado sem argumentos ou com 3 argumentos: ENERGIA e1 e2 e3 \n"
        try:
            lista_arg = list(arg)
            num_args = len(lista_arg)
            energ = 0
            
            if num_args == 0:
                for n in range(0,len(eng.coordenadas)-1):
                    a = [eng.coordenadas[n][0],eng.coordenadas[n][1]+1]
                    b = [eng.coordenadas[n][0],eng.coordenadas[n][1]-1]
                    c = [eng.coordenadas[n][0]+1,eng.coordenadas[n][1]]
                    d = [eng.coordenadas[n][0]-1,eng.coordenadas[n][1]]
                    lisaux=[a,b,c,d]
            
                    if eng.coordenadas[n+1] in lisaux:
                        lisaux.remove(eng.coordenadas[n+1])
                        if n > 0 and eng.coordenadas[n-1] in lisaux:
                            lisaux.remove(eng.coordenadas[n-1])              
                     
                        for i in range(0,len(lisaux)):                            
                            if lisaux[i] in eng.coordenadas:
                                letraAtual = eng.sequencia[n]
                                letraAux = eng.sequencia[eng.coordenadas.index(lisaux[i])]
                                if letraAtual == letraAux:
                                    if letraAtual == "A" and letraAux == "A" and lisaux[i] == eng.coordenadas[-1]: 
                                        energ -= 1
                                    else:
                                        energ -= 1/2
                print("Energia da sequência: ",round(energ,0))
                return energ
            elif num_args == 3:
                for n in range(0,len(eng.coordenadas)-1):
                    a = [eng.coordenadas[n][0],eng.coordenadas[n][1]+1]
                    b = [eng.coordenadas[n][0],eng.coordenadas[n][1]-1]
                    c = [eng.coordenadas[n][0]+1,eng.coordenadas[n][1]]
                    d = [eng.coordenadas[n][0]-1,eng.coordenadas[n][1]]
                    lisaux=[a,b,c,d]
            
                    if eng.coordenadas[n+1] in lisaux:
                        lisaux.remove(eng.coordenadas[n+1])
                        if n > 0 and eng.coordenadas[n-1] in lisaux:
                            lisaux.remove(eng.coordenadas[n-1])              
                        for i in range(0,len(lisaux)):                            
                            if lisaux[i] in eng.coordenadas:               
                                letraAtual = eng.sequencia[n]
                                letraAux = eng.sequencia[eng.coordenadas.index(lisaux[i])]
                                if letraAtual == letraAux:
                                    if letraAtual == "A" and letraAux == "A" and lisaux[i] == eng.coordenadas[-1]: 
                                        energ += int(lista_arg[0]) 
                                    elif letraAtual == "A" and letraAux == "A" and lisaux[i] != eng.coordenadas[-1]:
                                        energ += int(lista_arg[0])/2
                                    elif letraAtual == "B" and letraAux == "B" and lisaux[i] == eng.coordenadas[-1]: 
                                        energ += int(lista_arg[1]) 
                                    elif letraAtual == "B" and letraAux == "B" and lisaux[i] != eng.coordenadas[-1]:
                                        energ += int(lista_arg[1])/2
                                elif letraAtual != letraAux and lisaux[i] == eng.coordenadas[-1]: 
                                        energ += int(lista_arg[2])
                                else:
                                    energ += int(lista_arg[2])/2                 
                print("Energia da sequência: ",round(energ,0))
                return energ
                
            else:
                return("Número de argumentos inválido.")
            
        except BaseException as e:
            print("Erro: ao fazer o ENERGIA:", str(e))
    
#################################################################################################        	
    def do_reparar(self, arg):    
        " - Comando que deverá reparar uma configuração caso esta seja inválida achando a configuração mais próxima que seja válida: REPARAR \n"

        try:  

            lista_arg = list(eng.sequencia)
                                                                        ##########################
# AGORA PRA REPARAR AS COORDENADAS                                      # arranjar algo por aqui #
            i = 0                                                       ##########################
            n = 0
            listaOriginal = eng.coordenadas
            while n < len(listaOriginal):                    # dá para ir adicionando aqui ao len valores?
                a = [listaOriginal[n][0],listaOriginal[n][1]+1]    #  ver o que está mal
                b = [listaOriginal[n][0],listaOriginal[n][1]-1]
                c = [listaOriginal[n][0]+1,listaOriginal[n][1]]     
                d = [listaOriginal[n][0]-1,listaOriginal[n][1]]
                lisaux=[a,b,c,d] 
                if n < len(listaOriginal)-1:
                    if listaOriginal[n+1] not in lisaux:
                        if listaOriginal[n+1][1] > listaOriginal[n][1] and listaOriginal[n+1][1] - listaOriginal[n][1] > 1: 
                            novaCoord=[listaOriginal[n+1][0],(listaOriginal[n+1][1])-1]
                            while novaCoord[1] != listaOriginal[n][1]:
                                eng.coordenadas.append(novaCoord)
                                i += 1
                                novaCoord=[novaCoord[0],novaCoord[1]-1]
                        
                        if listaOriginal[n+1][1] < listaOriginal[n][1] and abs(listaOriginal[n][1]) - abs(listaOriginal[n-1][1])>1:
                            novaCoord=[listaOriginal[n+1][0],listaOriginal[n+1][1]+1]
                            while novaCoord[1] != listaOriginal[n][1]:
                                eng.coordenadas.append(novaCoord)    
                                i += 1
                                novaCoord=[novaCoord[0],novaCoord[1]+1]

                        if listaOriginal[n+1][0] > listaOriginal[n][0] and listaOriginal[n+1][0] - listaOriginal[n][0]>1:
                            novaCoord=[listaOriginal[n+1][0]-1,listaOriginal[n+1][1]]
                            while novaCoord[0] != listaOriginal[n][0]:
                                eng.coordenadas.append(novaCoord)
                                i += 1
                                novaCoord=[novaCoord[0]-1,novaCoord[1]]
                            print(listaOriginal)
                        if listaOriginal[n+1][0] < listaOriginal[n][0] and abs(listaOriginal[n][0]) - abs(listaOriginal[n+1][0])>1:
                            novaCoord=[listaOriginal[n+1][0]+1,listaOriginal[n+1][1]]
                            while novaCoord[0] != listaOriginal[n][0]:
                                eng.coordenadas.append(novaCoord)                   
                                i += 1                                              
                                novaCoord=[novaCoord[0]+1,novaCoord[1]]             
                n += 1

                lista_sem_repeticoes = list(set(tuple(sublista) for sublista in eng.coordenadas))
                eng.coordenadas = [list(sublista) for sublista in lista_sem_repeticoes]            
                eng.coordenadas = sorted(eng.coordenadas, key=lambda k: [k[0], k[1]])
                
                # ver quantas letras faltam para len(coordenadas)==len(sequencia) e só depois adicionar em random esse nº de letras
                while i > 0:
                    lista_arg.append(random.choice(['A', 'B']))
                    i-=1     
                s= ''.join(lista_arg) 
                while len(eng.coordenadas) != len(list(s)):
                    s = s.rstrip(s[-1])

                eng.setseq(s)
                                     
            # atribuir ao eng.sequencia a sequencia nova com as letras adicionadas
            print(eng.sequencia),print(eng.coordenadas)
        
        except BaseException as e:
            print("Erro: ao fazer o REPARAR:", str(e))

#################################################################################################            
	
    def do_proclocal(self,arg):    
        " - Comando que deverá encontrar uma configuração vizinha da configuração atual com energia mais baixa: PROCLOCAL \n"
        ##############################################
        #ideia: tentar ver se ha algum A na sequencia#
        #que possa ir para a beira de outro A. Se não#
        #    houver, ver qual é a melhor solucao.    #
        ##############################################
        try:  
            lista_arg = list(arg)
            num_args = len(lista_arg)
            if num_args == 0:
                a = int(self.do_energia(arg))
                b = 1000000
                while b >= a: 
                    dob = []
                    for i in range(0,len(eng.coordenadas)-1):  
                        dob.append(random.choice(['D','F','E']))
                    dob_str = ''.join(dob)
                    self.do_dobrar(dob_str)
                    b = self.do_energia(arg)
                    
            

        except BaseException as e:
            print("Erro: ao fazer o PROLOCAL:", str(e))
	
 #################################################################################################           
	
    def do_procurar(self, arg):    
        " - Comando que deverá encontrar a melhor configuração possível (i.e., a configuração com energia mais baixa) num espaço de tempo aceitável: PROCURAR \n"
        try:    
            lista_arg = list(arg)
            num_args = len(lista_arg)
            if num_args == 0:

                a = eng.coordenadas
                b = int(self.do_energia(""))
                for elem in comb:
                    self.do_dobrar(elem)
                    if int(self.do_energia("")) < b :
                        self.do_dobrar(elem)
            print("Configuração de energia mínima: ",eng.coordenadas)
        except BaseException as e:
            print("Erro: ao fazer o PROCURAR:", str(e))
#################################################################################################        	


    def do_ver(self, arg):    
        " - Comando para visualizar graficamente a configuração atual caso seja válida: VER  \n"
        try:
            if len(eng.getcoord()) > 0:
                for linha in eng.get_matriz_total():  # imprimir na consola toda a informação sobre a sequencia
                    print("%s - (%d,%d)" % (linha[0], linha[1], linha[2]))
                global janela  # pois pretendo atribuir um valor a um identificador global
                if janela is not None:  # pretendo criar uma nova janela para a área retangular, por isso é que apago a anterior, se existir.
                    del janela  # invoca o metodo destruidor de instancia __del__()
                cell_size = 50  # tamanho da quadricula em pixeis
                janela = ProteinasWindow(cell_size, eng.max_coord_x(), eng.min_coord_x(), eng.max_coord_y(), eng.min_coord_y()) 
                janela.mostraJanela(eng)
            else:
                print('Atenção: a lista de coordenadas está vazia!')
        except BaseException as e:
            print("Erro: ao mostrar a janela com o estado da sequência (gráfica):", str(e))
        pass
    
    def do_sair(self, arg):
        "Sair do programa Proteínas: sair"
        print('Obrigado por ter utilizado o Proteínas, espero que tenha sido útil!')
        return True


if __name__ == '__main__':
    eng = ProteinasEngine()
    janela = None
    sh = ProteinasShell()
    sh.cmdloop()
    
	
'''
para testar:

> seq BAAABABBBBBA
> coords (0,0)(1,0)(2,0)(2,-1)(3,-1)(3,0)(3,1)(4,1)(4,2)(3,2)(2,2)(2,1)
> ver

'''
